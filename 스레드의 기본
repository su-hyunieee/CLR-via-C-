26장.  스레드의 기본

1. 윈도우의 Thread도입 이유 
 초창기에는 하나의 프로세스가 운영체제 코드와 응용프로그램 코드를 모두 수행했다  
-> 동시에 다른작업을 수행할수 없다, 하나의 응용프로그램이 무한루프에 빠지면 그냥 컴퓨터를 종료 -> 정보 날라감  
새로운 운영체제 커널을 설계하고 계속 발전시킴 
 
 -> 스레드 개념 도입 
 Thread :  CPU를 가상화 하기 위한 윈도우 운영체제의 개념, 비용은 들지만 꼭 필요함 
프로세스들이 서로 영향을 끼치지 않아서, 하나의 프로세스가 무한루프에 빠지더라도 내 프로세스에는 영향을 주지 않음 
 
 
2. 스레드의 비용 
여러 응용프로그램들이 개별적으로 장신간의 작업들을 수행하고 있는 상황에서도 여러개의 스레드를 이용하면 운영체제의 응답성이 좋아지는 효과 
스레드를 사용하면 작업관리자 같은 응용프로그램을 이용하여 비정상적으로 장시간의 작업을 수행하고 있는 응용프로그램을 강제로 종료할수도 있다.   
하지만 ~~~~ 스레드 역시 추가적인 메모리와 시간비용을 발생시킨다  
 
스레드의 비용 리스트 (스레드라면 아래 5개를 다 가지고 있다) 
 
스레드 커널 객체 :  개별 스레드는 고유의 데이터 구조체를 가지고 있다. ( os 가 할당 및 초기화) 
커널에서 관리하는 중요한 정보를 담아둔 데이터 블록 
데이터 구조체 : 스레드를 나타내는 속성( 스레드 컨텍스트 포함)들을 가짐 
컨텍스트 : CPU내의 레지스터들의 값을 저장하고 있는 메모리 블록 
스레드 환경 블록(TEB) : 유저모드에 할당되고 초기화 되는 메모리 블록, 스레드 정보를 담고있는 구조체 
1페이지 크기 (4 KB) 
스레드의 예외 처리 체인의 가장 앞쪽을 푸함 
TLS(스레드 로컬저장소) 데이터와 GDI및 OpenGL 그래픽과 관련된 데이터 구조체 가짐 
유저모드 스택 : 지역변수와 함수의 매겨변수를 저장, 현재수행중인 함수가 반환될 때 다음으로 수행해야할 위치 저장 
1MB ( 더 많은 공간을 필요할 경우 조금씩 나누어 물리적 저장소를 커밋) 
커널 모드 스택 : 응용프로그램이 운영체제의 커널 모드 함수로 매개변수를 전달해야 할 때 사용 
DLL의 스레드 attach/detach통지 : DLLL들이 이 통지규칙을 이용하여 스레드 별로 특수한 초기화 작업/ 정리작업 수행 
         i) DLL_THREAD_ATTACH: 새로운 스레드 생성시, 해당 프로세스의 메모리공간에 로드된 모든 비관리 DLL들의 DllMain함수를 이 플래그를 통해 호출 
 ii) DLL_THREAD_DETACH : 스레드가 종료되면 이 플래그를 통해 DllMain 함수를 호출 
(C#으로 만들어진 DLL은 메인함수를 가지고 있지 않아서 통지 받지 않음) 
-> 사용예시 : C런타임 라이브러리 DLL 의 경우 이런 통지 잇을 때 TLS에 몇몇 상태정보를 저장해두고 ,해당 스레드가 C런타임 라이브러리 내오티특정 함수들을 사용할 때 활용한다 


 
 Q. C#은 DLL 들의 메인함수를 가지고 있지 않아서 ,통지 받지 않아서 성능 개선 가능하다 우리도 그렇게 쓰나 궁금하지만 어떻게 보는지 전혀 모르겠다 
 
스레드 비용이 많이 드는 
컨텍스트 전환(context switch) ->30초에 한번씩 (RR) 
주어진 타임 슬라이스(Time-slice(Quantum)) 동안만 수행. 타임 슬라이스가 완료 후 다른 스레드로 컨텍스트 전환 
1.      CPU 레지스터 값을 현재 수행 중 스레드 컨텍스트 구조체에 저장 
2.      다음 수행할 스레드 선택 (OS는 수행할 코드 및 데이터 접근을 위해 가상 메모리 주소를 확인 및 전환) 
3.      선택된 스레드의 컨텍스트 구조체 내의 값을 CPU 레지스터로 로드 
 
 -----> 컨텍스트 스위치를 통해 견고하고, 사용자에게 응답성이 좋은 운영체제를 구현할수 있다. 
 
하지만, 컨텍스트 전환 작업은 더 큰 비용을 가져올수도 있다 
-> 만약 CPU가 컨텍스트 스위치 없이 계속해서 이전 스레드를 수행한다면 , CPU 캐시는 많이 사용할수 있지만 전환시,,,  ->CPU캐시의 내용이 쓸모없어져 버림 
-> 가비지 컬렉트를 할라면 CLR은 모든 스레드를 일시정지 시킨다 , 
-> 스레드 재개에도 역시 비용이 든다  
 
스레드가 줄어들수록의 이득 
l  RAM이나 캐시메모리에 접근이 줄어들어 성능 향상 
l  GC가 덜 일어나 성능 향상 
l  되도록 스래드의 개수를 컴퓨터의 CPU수와 일치 
출처: <https://mtding00.tistory.com/43>  
 
 
결론 : 스레드가 많은수록 좋은 것은 아니다 !!!!!!! 가능한 만들지 않는것이 좋지만, 응답성이 좋은 os를 만들기 위해 사용할수밖에 없다 
 
그럼에도, 여러스레드를 사용하는 이유  
 
l  응답성 
응용프로그램이 무한루프에 빠지더라도 사용자가 다른 응용프로그램 사용 전체적으로 보자면…. 
 
l  성능 
CPU가 각자에게 할당된 스레드를 동시에 수행  = 병렬로 여러작업 동시에 수행 가능 => 성능 개선!!  
-현재는  cpu 가 이미 여러개의 코어를 가지고 있기 때문에 성능 개선 완전 가능~~ 
 
CPU의 개수가 많다면 ? 
-> os는 하나의 스레드를 개별 cpu코어에 할당하고, 각각의 코어는 개별적으로 다른 스레드로의 컨텍스트 스위칭을 하게된다.  -> 효율적 
스레드 개수 = cpu수 일때 최적임 
 
 
CPU의 발전방향  
Cpu의 속도 ↑ 발열 ↑ -> 하드웨어제조사의 문제상황 봉착 !!!!  -> cpu 속도개선 대신 트랜지스터를 작게 만들어 단일의 칩에 더 많은 트랜지스터를 집적하게됨 
->  단일의 칩이 cpu 코어를 여러 개 가질수 있다 
 
여러개의 CPU 사용: 여러개의 CPU를 사용(마더보드에 여러개의 cpu를 장착) 
하이퍼스레드 칩 : 인텔이 소유, 단일의 칩이 두개의 칩을 가지고 있는것 처럼  
멀티 코어 칩 :단일 칩에 여러개의  CPU 코어를 집적하는 방식, 멀티 코어 칩에 하이퍼스레드도 가능 
 
필자의 의견 : CPU가 100퍼센트 사용되는것이 좋지 않은가 ? 지금 이걸 작성하고 있는 내 cpu는 5%만 사용…  
배터리에 의해 동작되는 경우 
다섯대의 컴퓨터가 백퍼 씨피유 << 10대의 컴퓨터가 오십퍼 수준으로  cpu 사용하는게 낫다  ---> 실질적인 비교 검토 
Q2. 우리 게임은 cpu를 몇퍼 써야 잘 쓰는걸까 ?? 95퍼는 써야지 않나 ?? 
 
==> 소프트웨어는 어떻게 해야 할까?? : 스레드를 지능적으로 사용해야 한다. 
 
CLR thread 와  Window thread 
  CLR은 윈도우 스레드 기능을 사용한다. 모든 CLR thread    window os thread  
CLR  : 기존의 os thread에는 존재하지 않는다..  Thread 가 어떤 heap에 접근하고, 보안, 실행,하는지 관리 ~ 
https://www.csharpstudy.com/DevNote/Article/1, https://dataonair.or.kr/db-tech-reference/d-lounge/expert-column/?mod=document&uid=53148 
 
 
CLR 쓰레드는 .NET Framework의 System.Threading.Thead로 표현되는데, 기존의 OS 쓰레드에는 존재하지 않는 CLR이 필요로하는 추가 정보들을 갖고 있다. CLR은 CLR 쓰레드가 어떤 Managed Heap 객체를 접근하고 있는지등의 정보를 비롯하여 CLR의 보안(Security), 실행 Context 등 CLR 쓰레드 고유의 정보를 Track하게 된다. 이렇게 별도의 CLR 쓰레드를 만들게 됨으로서 이루어져야 하는 OS 쓰레드에서 CLR 쓰레드로의 전환, 혹은 그 반대로의 전환은 CLR이 자동으로 처리해 준다. 
.NET Applicaiton 프로세스는 메인쓰레드와 Finalizer 쓰레드 등 최소 2개의 CLR 쓰레드를 비롯하여 복수의 쓰레드들을 갖는다. .NET 프로그램을 실행한 후 Windbg 같은 Debugger로 살펴 보면, Managed Thread와 Native Thread를 자세히 살펴 볼수 있다. 예를 들어, 아주 간단한 WinForm 프로그램을 만들어 Windbg로 살펴보면, 아래 예에서는 Native OS 쓰레드는 7개가 있음을 알 수 있다. (주: Windbg에서 ~ 명령은 모든 쓰레드를 표시하라는 명령이다) 
 
출처: <https://www.csharpstudy.com/DevNote/Article/1>  
 
 
 
 
스레드 스케줄링과 우선순위 
 
윈도우는 스레드를 스케줄링 대상으로 삼는다. 
 
스레드 우선순위 
0-31 까지 (31이 높은거임) ( 0레벨은 제로 페이지 스레드 : 다른 스레드가 없을 때 RAM의 내용을 0으로 바꿈) 
17~30 은 커널 모드에서만 사용 가능하다. 
프로세스의 우선순위 + 상대 스레드 우선순위를 조합 
라운드 로빈 방식으로 스케줄링 
스레드의 우선순위는 항상 프로세스 우선순위 클래스와 연관 되어 있다 
 
31이 스케줄 가능한 상태에 있는 동안 0- 31은  cpu를 할당받지 못한다 -> starvation  우선순위 높은애가 독식 
---> 이것도 멀티 코어의 장점 . . . 
 
프로세스 우선순위 
응용프로그램을 설계할 때 다른 프로그램보다 좀 더 빠르게 응답하거나 느리게 응답하기를 바란다면, 프로세스 우선순위를 선택하면 된다.  
프로세스가 수행되는 시점에 결정 
 [유휴, 보통이하, 보통, 보통이상, 높음, 실시간] 으로 구분된다. 대부분은 보통수준!! 가진다. .~ 
유휴 : 화면 보호기같은거,,  
높음 :  반드시 필요한 경우에만..  
실시간 : 디스크 I/O 나 네트워크 작업을 방해할 수 있음.. 마우스나 키보드 동작을 방해해서 사용자 열받게 할수도 .. 
따라서 아주 기민하게 반응해야 하거나, 아주 짧은 시간만 수행되는 작업에만 적용해야 한다.  
 
프로세스 우선순위를 정했다면 ….  상대 스레드 우선순위 
 다른 응용프로세스들과의 연관성 말고 내 응용프로그램 안의 스레드들간의 연관성에 집중 해야 한다 !!!! 
상대 스레드 우선순위는 [유휴, 가장낮음, 보통이하, 보통, 보통이상, 가장높음, 타임크리티컬] 로 나뉜다. CLR의 finalizer 스레드는 타임 크리티컬 우선순위를 갖는다. 
  
다른 스레드의 우선순위를 높이는 것 보다 자신의 우선순위를 낮추는 방법이 더 좋다.  
-> 코드 컴파일, 맞춤법검사등의 장시간 수행 작업은 낮은 우선순위를 가짐 
->키보드에서 윈도우키를 누를때, 높은 우선순위 -> 빠르게 응답하고 대기 상태로 돌아가야하는 경우  
  
CPU를 100%활용하려면 이런 스레드 우선순위를 신중하게 고려해야 한다. 
 
 
포그라운드 스레드 백그라운드 스레드 
CLR은 모든 스레드를 포그라운드 또는 백그라운드로 인식한다.  
포그라운드 스레드가 종료되면 수행중인 백그라운드 스레드들을 모두 강제종료 하려고 시도하게되고, 백그라운드 스레드는 아무런 예외를 발생시키지 않고 즉각종료된다. 
CLR은 포그라운드 스레드와 벡그라운드 스레드의  개념을 앱도메인이 더욱 잘 수행될수 있도록 하기 위해서 활용할 필요가 있다. 
응용프로그램의 주스레드와 객체로 선언 -- 포그라운드 
스레드 풀 -- 백그라운드 
 
 
 
스레드 풀이란 개념이 있는데, 여기의 스레드는 백그라운드 스레드로 작동한다.  ->27장…..에서 …. 
스레드를 가장 잘 활용하는 방법은 스레드 풀을 사용하는것이다. 스레드 생성과 파괴 자동수행, 재활용----> 최소한의 스레드 이용.. 
 
 
싱글 스레드 프로그램은 단 하나의 코어만을 사용하므로 코어의 수가 증가해도 큰 차이가 없다... 
따라서 여러 개의 코어를 활용할 수 있도록 한 프로세스를 여러 스레드로 쪼개어 연산하도록 한다. 
 
 
 
 
 
 
 
 
